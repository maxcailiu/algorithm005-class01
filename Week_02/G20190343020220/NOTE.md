学习笔记


## 第二周学习总结

### hashmap源码分析

经典哈希表结构. 数组+单链表. 
jdk的优化是 为了解决链表太长导致查询退化的情况. 当链表长度超过阈值的时候, 进入红黑树

#### 为什么数组桶的长度要是2的次幂
因为哈希表的性能由两个地方决定. 1. hash函数的执行效率. 2.哈希函数是否均匀(减少冲突)

1. 为了提高哈希函数的执行效率 将%运算换从了&运算. 剩下的就是解决减少碰撞的问题. 在减少碰撞的问题是. 

在java jdk不会直接使用hashcode, 而是
```java
 static final int hash(object key) {
         int h;
         return (key == null) ? 0 : (h = key.hashcode()) ^ (h >>> 16);
     }

```
加入了扰动函数. int是32位. 高16位和低16位进行异或运算(相同为0, 不同为1). 得到key在和 key & n-1运算. 这样使得key的哈希值的32位数全部参数了运算. 减少哈希冲突的可能性. 另外还增加了红黑树结构.
即便是在碰撞严重的情况, 依旧能够保证o(logn)的时间复杂度.  而且顺便还解决了一个安全问题.

dos攻击, 就是针对哈希表的链表的攻击. 如果恶意程序知道我们用的是hash算法，则在纯链表情况下，它能够发送大量请求导致哈希碰撞，然后不停访问这些key导致hashmap忙于进行线性查找，最终陷入瘫痪，即形成了拒绝服务攻击（dos）。
由于红黑树的存在. 这种问题就会好很对. 但是还是无法解决内存资源耗尽的问题. 

2. 关于n  2的次幂的二进制的规律是只有一个位置为1. 其他的位置都是0 比如2(0010) 4(0100) 8(1000), 1(0001) 3(0011) 7(0111)

&运算 是1&1=1 0&1=0 1&0=0 0&0=0; 

所以key & n-1. 低位的1就是起决定性作用的. 当n=8时 保证了算出来的桶位置index. 在0到7的范围内的.

3. 扩容. 扩容也是减少哈希碰撞的方式, jdk的默认负载因子为0.75. 当大于阈值的时. 扩容为原数组长度的2被. 比如数组长度为16, 16*0.75=12. 也就是说, 哈希表中元素个数>=12时, 就会触扩容. 将16 << 1 = 32;

扩容说白了就是对hash表中的所有元素重新key & n-1计算桶索引i. 但是这个计算是有规律的. 我们发现.每次扩容一倍在结合桶长度为2的次幂. 会出现.扩容的后元素的位置.

对于n-1来说, 就是高位增加了1位 为1. 比如从16(0001 0000)扩容到32(0010 0000). n-1的变化时从15(0000 1111)到31(0001 1111). 
![20191216135806.png](https://ten951-img.oss-cn-shanghai.aliyuncs.com/20191216135806.png)

会出现一个规律. 原索引的高位如果是0 那么扩容后的索引位置没变. 如果高位是1. 那么新索引的位置为oldi+oldCap. 

通过这种方式, 减少了哈希表扩容时的哈希计算问题. 又增加了效率.

#### putval方法



jdk1.8的put方法执行流程是: 
1. 查看桶table是否为空,  如果为空 则初始化桶.
2. 桶不为空. 通过hash & (n-1) 计算桶索引位置i.  判断i是否为null.  如果为null. 说明没有冲突. new node()直接添加.
3. 当i位置, 也就是桶的位置不为null的时候.  说明存在hash冲突. 拿到链表p. 判定p.key和新添加的e.key是否相等. 相等说明链表头的位置就是目标位置. 直接替换
4. 发现链表p的key和要添加的key不相等. 说明链表要遍历这个链表了. 先判断这个链表是不是红黑树. 如果是红黑树 .调用红黑树的put方法
5. 发现不是红黑树. 说明有两种情况. 1. 新key可能在链表中的某个位置. 2 key不存在链表中, 要新加到末尾. 这两种都需要遍历链表. 在途中判定是否和新key相同. 相同替换. 没找到在将新key包装成node添加到链表末尾. 添加完成后. 查看链表长度是否>=7.大于转成红黑树.
6. 判定数组的长度是否>阈值. 大于就会扩容. 这也是减少冲突的一种方案.

#### get方法

1. 数组不为空 && 数组长度n>0 && table[hash & (n-1)] != null. 经过这些判定. 确定key在哈希表中存在. 
2. key在表存在. 判定桶i的位置p链表 是否和当期要查找的key相同.  相同就是要找的, 直接返回
3. 不相同. 判定是否为红黑树.  是 调用红黑树的find方法
4. 不是红黑树. 遍历链表. 从头向后比遍历. 知道到key相同的. 则返回
5. 其他任何情况都返回null. 



 ## leetcode刷题
 
 ### https://leetcode-cn.com/problems/valid-anagram/submissions/ 是否为异位词
 
 解题思路: 映射表
 当字符串s和t 长度不相等时. false
 
 构建一个26个字母的int数组, 遍历其中一个字符串的.  因为都是小写字母. 所以当一个小写的char-'a' 就会得到这些字母对于的ASCII码值. 当任何一个位置!=0时, 返回false
 
 时间复杂度: O(n) 
 空间复杂度: O(1) 因为固定26个大小的数组
 
 ### https://leetcode-cn.com/problems/group-anagrams/submissions/ 字母异位词分组
 
 解题思路: 哈希表
 
 遍历整个异位词数组. 然后将字符串s排序.得到新字符串n, (异位词排序后字符串是相等的)  然后判断n是否哈希表中. 如果存在在哈希表中. 取得list将字符串s添加到list中. 不存在将n添加到哈希表中.
 
 ### https://leetcode-cn.com/problems/two-sum/
 
 解题思路: 哈希表
 
 遍历数组, 计算每个元素s和target的差. 判定差值是否在map中, 存在那么当前的下标i和map中存在的下j, 相加=target的组合,  不存在将元素s当k, v为下标 添加到哈希表中